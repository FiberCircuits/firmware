# Firmware

This repo is for a project that explores the idea of accessible electronic miniaturization, using the smallest ARM processor, the STM32C011D6 in a WLCSP package (1.4mm wide).
It is used here to stream data from the smallest accelerometer (MC3672) in the market, and control
the smallest addressable LEDs (APA-104-1010).


## Required hardware

This firmware was develpped for a custom STM32 board, with 1st tests on this dev board:
  - [STM32C0116_DK](https://www.st.com/en/evaluation-tools/stm32c0116-dk.html)

The following sensor dev board can be used:
  - [MC3672](https://www.digikey.com/en/products/detail/memsic-inc./EV3672B/12088271)


## Required software

  - [arduino](http://arduino.cc)
  - [stm32duino](https://github.com/stm32duino/Arduino_Core_STM32)
  - [ADCTouchSensor](https://github.com/arpruss/ADCTouchSensor)
  - [Adafruit_NeoPixel](https://github.com/adafruit/Adafruit_NeoPixel)


## Compilation

These parameters must be chosen in the `Tools` menu:
  - Board: "Generic STM32C0 series"
  - Board Part Number: "Generic C011D6Yx"
  - Optimize: "Smallest (-Os) with LTO"
  - default for the rest

Note: you might have to press the reset button after upload.


## Memory optimization


### Problem

The target MCU has a limited flash memory (32KB) and some optimizations were necessary to fit everything in.

The main one consisted in avoiding the double precision that GCC uses by default fairly often.

Casting them could work but it forces the user to analyse the binary with tools such as arm-none-eabi-nm and arm-none-eabi-objdump (more below).


### Solutions

#### 1) Currently implemented

The `build_opt.h` file allows giving options to the compiler, for example to force using floats instead of doubles (here we use `-fsingle-precision-constant`).

This means that if you actually need double precision, you should remove this file.

#### 2) Future proofing

If you need other libraries and want to investigate the memory usage of all the hidden functions used, some commands can help:

##### 2.1) find the binary

Around the end of the compilation output, you  will get something like this:

` /home/USER/.arduino15/packages/STMicroelectronics/tools/xpack-arm-none-eabi-gcc/12.2.1-1.2/bin/arm-none-eabi-size -A /tmp/arduino_build_246842/firmware.ino.elf `

=> Go to the `tmp` directory given at the end of that line (`/tmp/arduino_build_246842/`).

##### 2.2) analyse the binary:

- If the compilation worked:
   - `arm-none-eabi-nm --print-size --size-sort --radix=d *.elf` # focus on the bottom functions
   - `arm-none-eabi-objdump -S *.elf ` # find them in the code and try to avoid them

- If the compilation failed because there's not enough space:

The elf will not be generated so the above commands won't work, but you can temporarily use a similar STM32 with bigger memory (ex: G031Y8Yx).

The G0 might even give you enough space to enable the -g debug option (in Tools), which adds more context (C and comments) in the assembly code generated by objdump (it's more readable).



## Legacy

The following lib was incorporated directly to enable various features:
- [github.com/cphuangf/Accelerometer_MC3672/](https://github.com/cphuangf/Accelerometer_MC3672/)
- [github.com/adafruit/Adafruit_MMC56x3](https://github.com/adafruit/Adafruit_MMC56x3)

